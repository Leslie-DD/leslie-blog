import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o,c,a as s,b as n,d as t,e}from"./app-B7vEFjvW.js";const i={},r=s("h2",{id:"定义",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#定义"},[s("span",null,"定义")])],-1),u={href:"https://en.wikipedia.org/wiki/Merge_sort",target:"_blank",rel:"noopener noreferrer"},m=s("h2",{id:"性质",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#性质"},[s("span",null,"性质")])],-1),k=s("p",null,[n("归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，空间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),d=s("p",null,[n("归并排序可以只使用 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n(" 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。")],-1),h=e(`<h2 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h2><h3 id="合并" tabindex="-1"><a class="header-anchor" href="#合并"><span>合并</span></a></h3><p>归并排序最核心的部分是合并（merge）过程：将两个有序的数组 <code>a[i]</code> 和 <code>b[j]</code> 合并为一个有序数组 <code>c[k]</code>。</p><p>从左往右枚举 <code>a[i]</code> 和 <code>b[j]</code>，找出最小的值并放入数组 <code>c[k]</code>；重复上述过程直到 <code>a[i]</code> 和 <code>b[j]</code> 有一个为空时，将另一个数组剩下的元素放入 <code>c[k]</code>。</p><p>为保证排序的稳定性，前段首元素小于或等于后段首元素时（<code>a[i] &lt;= b[j]</code>）而非小于时（<code>a[i] &lt; b[j]</code>）就要作为最小值放入 <code>c[k]</code>。</p><h4 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h4><div class="hint-container info"><p class="hint-container-title">&quot;C/C++&quot;</p><p>&quot;数组实现&quot;</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> size_t aLen<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> size_t bLen<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> aLen <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> bLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// &lt;!&gt; 先判断 b[j] &lt; a[i]，保证稳定性</span>
      c<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token operator">++</span>j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      c<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token operator">++</span>i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>k<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> aLen<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bLen<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>&quot;指针实现&quot;</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>aBegin<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>aEnd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>bBegin<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>bEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>aBegin <span class="token operator">!=</span> aEnd <span class="token operator">&amp;&amp;</span> bBegin <span class="token operator">!=</span> bEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>bBegin <span class="token operator">&lt;</span> <span class="token operator">*</span>aBegin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>bBegin<span class="token punctuation">;</span>
      <span class="token operator">++</span>bBegin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>aBegin<span class="token punctuation">;</span>
      <span class="token operator">++</span>aBegin<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span>c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> aBegin <span class="token operator">!=</span> aEnd<span class="token punctuation">;</span> <span class="token operator">++</span>aBegin<span class="token punctuation">,</span> <span class="token operator">++</span>c<span class="token punctuation">)</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>aBegin<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> bBegin <span class="token operator">!=</span> bEnd<span class="token punctuation">;</span> <span class="token operator">++</span>bBegin<span class="token punctuation">,</span> <span class="token operator">++</span>c<span class="token punctuation">)</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>bBegin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>也可使用 \`&lt;algorithm&gt;\` 库的 \`merge\` 函数，用法与上述指针式写法的相同。
</code></pre></div><div class="hint-container info"><p class="hint-container-title">&quot;Python&quot;</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>
    c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">and</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># &lt;!&gt; 先判断 b[j] &lt; a[i]，保证稳定性</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            c<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token comment"># 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中</span>
    c<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h3 id="分治法实现归并排序" tabindex="-1"><a class="header-anchor" href="#分治法实现归并排序"><span>分治法实现归并排序</span></a></h3>`,9),g=s("ol",null,[s("li",null,[s("p",null,[n("当数组长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 时，该数组就已经是有序的，不用再分解。")])]),s("li",null,[s("p",null,[n("当数组长度大于 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 时，该数组很可能不是有序的。此时将该数组分为两段，再分别检查两个数组是否有序（用第 1 条）。如果有序，则将它们合并为一个有序数组；否则对不有序的数组重复第 2 条，再合并。")])])],-1),v=s("p",null,"用数学归纳法可以证明该流程可以将一个数组转变为有序数组。",-1),b=s("p",null,[n("为保证排序的复杂度，通常将数组分为尽量等长的两段（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"d"),s("mo",null,"="),s("mrow",null,[s("mo",{fence:"true"},"⌊"),s("mstyle",{displaystyle:"true",scriptlevel:"0"},[s("mfrac",null,[s("mrow",null,[s("mi",null,"l"),s("mo",null,"+"),s("mi",null,"r")]),s("mn",null,"2")])]),s("mo",{fence:"true"},"⌋")])]),s("annotation",{encoding:"application/x-tex"},"mid = \\left\\lfloor \\dfrac{l + r}{2} \\right\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"2.4em","vertical-align":"-0.95em"}}),s("span",{class:"minner"},[s("span",{class:"mopen delimcenter",style:{top:"0em"}},[s("span",{class:"delimsizing size3"},"⌊")]),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.3714em"}},[s("span",{style:{top:"-2.314em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2")])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.677em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.686em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})]),s("span",{class:"mclose delimcenter",style:{top:"0em"}},[s("span",{class:"delimsizing size3"},"⌋")])])])])]),n("）。")],-1),y=s("h4",{id:"实现-1",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#实现-1"},[s("span",null,"实现")])],-1),w=s("p",null,[n("注意下面的代码所表示的区间分别是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"l"),s("mo",{separator:"true"},","),s("mi",null,"r"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[l, r)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),s("span",{class:"mclose"},")")])])]),n("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"l"),s("mo",{separator:"true"},","),s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"d"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[l, mid)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mclose"},")")])])]),n("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"d"),s("mo",{separator:"true"},","),s("mi",null,"r"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[mid, r)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),s("span",{class:"mclose"},")")])])]),n("。")],-1),x=e(`<div class="hint-container info"><p class="hint-container-title">&quot;C/C++&quot;</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 分解</span>
  <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 合并</span>
  <span class="token keyword">int</span> tmp<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用</span>
                        <span class="token comment">// vector；先将合并的结果放在 tmp 里，再返回到数组 a</span>
  <span class="token function">merge</span><span class="token punctuation">(</span>a <span class="token operator">+</span> l<span class="token punctuation">,</span> a <span class="token operator">+</span> mid<span class="token punctuation">,</span> a <span class="token operator">+</span> mid<span class="token punctuation">,</span> a <span class="token operator">+</span> r<span class="token punctuation">,</span> tmp <span class="token operator">+</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// pointer-style merge</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><div class="hint-container info"><p class="hint-container-title">&quot;Python&quot;</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> ll<span class="token punctuation">,</span> rr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> rr <span class="token operator">-</span> ll <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token comment"># 分解</span>
    mid <span class="token operator">=</span> <span class="token punctuation">(</span>rr <span class="token operator">+</span> ll<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
    merge_sort<span class="token punctuation">(</span>a<span class="token punctuation">,</span> ll<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
    merge_sort<span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> rr<span class="token punctuation">)</span>
    <span class="token comment"># 合并</span>
    a<span class="token punctuation">[</span>ll<span class="token punctuation">:</span>rr<span class="token punctuation">]</span> <span class="token operator">=</span> merge<span class="token punctuation">(</span>a<span class="token punctuation">[</span>ll<span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">:</span>rr<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h3 id="倍增法实现归并排序" tabindex="-1"><a class="header-anchor" href="#倍增法实现归并排序"><span>倍增法实现归并排序</span></a></h3>`,3),f=s("p",null,[n("已知当数组长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 时，该数组就已经是有序的。")],-1),_=s("p",null,[n("将数组全部切成长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 的段。")],-1),M=s("p",null,[n("从左往右依次合并两个长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),n(" 的有序段，得到一系列长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"\\le 2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),n(" 的有序段；")],-1),L=s("p",null,[n("从左往右依次合并两个长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"\\le 2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),n(" 的有序段，得到一系列长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"4")]),s("annotation",{encoding:"application/x-tex"},"\\le 4")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"4")])])]),n(" 的有序段；")],-1),j=s("p",null,[n("从左往右依次合并两个长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"4")]),s("annotation",{encoding:"application/x-tex"},"\\le 4")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"4")])])]),n(" 的有序段，得到一系列长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"8")]),s("annotation",{encoding:"application/x-tex"},"\\le 8")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"8")])])]),n(" 的有序段；")],-1),B=e(`<p>……</p><p>重复上述过程直至数组只剩一个有序段，该段就是排好序的原数组。</p><div class="hint-container info"><p class="hint-container-title">&quot; 为什么是 $\\le n$ 而不是 $= n$&quot;</p><pre><code>数组的长度很可能不是 $2^x$，此时在最后就可能出现长度不完整的段，可能出现最后一个段是独立的情况。
</code></pre></div><h4 id="实现-2" tabindex="-1"><a class="header-anchor" href="#实现-2"><span>实现</span></a></h4><div class="hint-container info"><p class="hint-container-title">&quot;C/C++&quot;</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> tmp<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用</span>
                        <span class="token comment">// vector；先将合并的结果放在 tmp 里，再返回到数组 a</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t seg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> seg <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> seg <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t left1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> left1 <span class="token operator">&lt;</span> n <span class="token operator">-</span> seg<span class="token punctuation">;</span>
          left1 <span class="token operator">+=</span> seg <span class="token operator">+</span> seg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// n - seg: 如果最后只有一个段就不用合并</span>
      size_t right1 <span class="token operator">=</span> left1 <span class="token operator">+</span> seg<span class="token punctuation">;</span>
      size_t left2 <span class="token operator">=</span> right1<span class="token punctuation">;</span>
      size_t right2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>left2 <span class="token operator">+</span> seg<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &lt;!&gt; 注意最后一个段的边界</span>
      <span class="token function">merge</span><span class="token punctuation">(</span>a <span class="token operator">+</span> left1<span class="token punctuation">,</span> a <span class="token operator">+</span> right1<span class="token punctuation">,</span> a <span class="token operator">+</span> left2<span class="token punctuation">,</span> a <span class="token operator">+</span> right2<span class="token punctuation">,</span>
            tmp <span class="token operator">+</span> left1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// pointer-style merge</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> left1<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><div class="hint-container info"><p class="hint-container-title">&quot;Python&quot;</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    seg <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">while</span> seg <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> l1 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> seg<span class="token punctuation">,</span> seg <span class="token operator">+</span> seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
            r1 <span class="token operator">=</span> l1 <span class="token operator">+</span> seg
            l2 <span class="token operator">=</span> r1
            r2 <span class="token operator">=</span> l2 <span class="token operator">+</span> seg
            a<span class="token punctuation">[</span>l1<span class="token punctuation">:</span>r2<span class="token punctuation">]</span> <span class="token operator">=</span> merge<span class="token punctuation">(</span>a<span class="token punctuation">[</span>l1<span class="token punctuation">:</span>r1<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>l2<span class="token punctuation">:</span>r2<span class="token punctuation">]</span><span class="token punctuation">)</span>
    seg <span class="token operator">&lt;&lt;</span><span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h2 id="逆序对" tabindex="-1"><a class="header-anchor" href="#逆序对"><span>逆序对</span></a></h2>`,7),z=s("p",null,[n("逆序对是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i"),s("mo",null,"<"),s("mi",null,"j")]),s("annotation",{encoding:"application/x-tex"},"i < j")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6986em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.854em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05724em"}},"j")])])]),n(" 且 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"a"),s("mi",null,"i")]),s("mo",null,">"),s("msub",null,[s("mi",null,"a"),s("mi",null,"j")])]),s("annotation",{encoding:"application/x-tex"},"a_i > a_j")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6891em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"a"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7167em","vertical-align":"-0.2861em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"a"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05724em"}},"j")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2861em"}},[s("span")])])])])])])])]),n(" 的有序数对 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"i"),s("mo",{separator:"true"},","),s("mi",null,"j"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"(i, j)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05724em"}},"j"),s("span",{class:"mclose"},")")])])]),n("。")],-1),q=s("p",null,[n("排序后的数组无逆序对，归并排序的合并操作中，每次后段首元素被作为当前最小值取出时，前段剩余元素个数之和即是合并操作减少的逆序对数量；故归并排序计算逆序对数量的额外时间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，对于 C/C++ 代码将 "),s("code",null,"merge"),n(" 过程的 "),s("code",null,"if(b[j] < a[i])"),n(" 部分加上 "),s("code",null,"cnt += aLen - i"),n(" 或 "),s("code",null,"cnt += aEnd - aBegin"),n(" 即可，对于 Python 代码将 "),s("code",null,"merge"),n(" 过程的 "),s("code",null,"if(b[j] < a[i]):"),n(" 部分加上 "),s("code",null,"cnt += len(a) - i"),n(" 即可。")],-1),E=s("p",null,[n("此外，逆序对计数即是将元素依次加入数组时统计当前大于其的元素数量，将数组离散化后即是区间求和问题，使用树状数组或线段树解决的时间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[n("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n(" 且空间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("。")],-1),T=s("h2",{id:"外部链接",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#外部链接"},[s("span",null,"外部链接")])],-1),C={href:"https://www.geeksforgeeks.org/merge-sort/",target:"_blank",rel:"noopener noreferrer"},N={href:"https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"},P={href:"https://zh.wikipedia.org/wiki/%E9%80%86%E5%BA%8F%E5%AF%B9",target:"_blank",rel:"noopener noreferrer"};function $(A,D){const a=l("ExternalLinkIcon");return o(),c("div",null,[r,s("p",null,[n("归并排序（"),s("a",u,[n("merge sort"),t(a)]),n("）是高效的基于比较的稳定排序算法。")]),m,k,d,h,g,v,b,y,w,x,f,_,M,L,j,B,z,q,E,T,s("ul",null,[s("li",null,[s("a",C,[n("Merge Sort - GeeksforGeeks"),t(a)])]),s("li",null,[s("a",N,[n("归并排序 - 维基百科，自由的百科全书"),t(a)])]),s("li",null,[s("a",P,[n("逆序对 - 维基百科，自由的百科全书"),t(a)])])])])}const S=p(i,[["render",$],["__file","merge-sort.html.vue"]]),V=JSON.parse('{"path":"/algorithms/sort/merge-sort.html","title":"","lang":"zh-CN","frontmatter":{"description":"定义 归并排序（merge sort）是高效的基于比较的稳定排序算法。 性质 归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 Θ(nlogn)，空间复杂度为 Θ(n)。 归并排序可以只使用 Θ(1) 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。 过程 合并 归并排序最核心的部分是合并（merge）过程：将两个有...","head":[["meta",{"property":"og:url","content":"https://leslie-dd.github.io/leslie-blog/leslie-blog/algorithms/sort/merge-sort.html"}],["meta",{"property":"og:site_name","content":"Leslie的博客"}],["meta",{"property":"og:description","content":"定义 归并排序（merge sort）是高效的基于比较的稳定排序算法。 性质 归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 Θ(nlogn)，空间复杂度为 Θ(n)。 归并排序可以只使用 Θ(1) 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。 过程 合并 归并排序最核心的部分是合并（merge）过程：将两个有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-19T07:24:37.000Z"}],["meta",{"property":"article:author","content":"Leslie"}],["meta",{"property":"article:modified_time","content":"2024-04-19T07:24:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-19T07:24:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Leslie\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"性质","slug":"性质","link":"#性质","children":[]},{"level":2,"title":"过程","slug":"过程","link":"#过程","children":[{"level":3,"title":"合并","slug":"合并","link":"#合并","children":[]},{"level":3,"title":"分治法实现归并排序","slug":"分治法实现归并排序","link":"#分治法实现归并排序","children":[]},{"level":3,"title":"倍增法实现归并排序","slug":"倍增法实现归并排序","link":"#倍增法实现归并排序","children":[]}]},{"level":2,"title":"逆序对","slug":"逆序对","link":"#逆序对","children":[]},{"level":2,"title":"外部链接","slug":"外部链接","link":"#外部链接","children":[]}],"git":{"createdTime":1713511477000,"updatedTime":1713511477000,"contributors":[{"name":"Leslie","email":"LeslieDYF@gmail.com","commits":1}]},"readingTime":{"minutes":5.26,"words":1577},"filePathRelative":"algorithms/sort/merge-sort.md","localizedDate":"2024年4月19日","excerpt":"<h2>定义</h2>\\n<p>归并排序（<a href=\\"https://en.wikipedia.org/wiki/Merge_sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">merge sort</a>）是高效的基于比较的稳定排序算法。</p>\\n<h2>性质</h2>\\n<p>归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi mathvariant=\\"normal\\">Θ</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">\\\\Theta (n \\\\log n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">Θ</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mop\\">lo<span style=\\"margin-right:0.01389em;\\">g</span></span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>，空间复杂度为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi mathvariant=\\"normal\\">Θ</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">\\\\Theta (n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">Θ</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>。</p>","autoDesc":true}');export{S as comp,V as data};
