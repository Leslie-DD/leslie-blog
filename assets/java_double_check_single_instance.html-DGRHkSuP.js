import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as n}from"./app-D30M7Ei4.js";const e="/leslie-blog/assets/fgmpfth72x-CwcSX9Hf.jpeg",l={},t=n('<p><img src="'+e+`" alt=""></p><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>单例模式在Java开发中是非常经典和实用的一种设计模式，在JDK的内部包的好多api都采用了单例模式，如我们熟悉的Runtime类.</p><p>单例模式总的来说有两种创建方式，一种是延迟加载的模式，一种是非延迟加载的模式，今天我们来学习一下基于双检锁延迟加载的单例模式。</p><h2 id="什么是单例模式" tabindex="-1"><a class="header-anchor" href="#什么是单例模式"><span>什么是单例模式</span></a></h2><p>顾名思义，单例模式指的是在整个程序运行期间，我们只能初始化某个类一次，然后一直使用这个实例，尤其是在多线程的环境下，也要保证如此。</p><h2 id="基于双检锁的单例模式" tabindex="-1"><a class="header-anchor" href="#基于双检锁的单例模式"><span>基于双检锁的单例模式</span></a></h2><p>在介绍基于双检锁的单例模式下，我们先思考下如何在使用延迟加载的情况下实现一个单例模式，可能有一些比较年轻的小伙伴，不假思索的就写下了下面的一段代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> DoubleCheckSingleton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getErrorInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码在单线程的环境下是没有问题的，但是在多线程的环境下是不能保证只创建一个实例的， 然后小伙伴想了下，这还不简单，加个同步关键字就可以了：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> DoubleCheckSingleton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getErrorInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，这下看起来没问题，但唯一的不足就是，这段代码虽然可以保证只创建一个单例，但其性能不高，因为每次访问这个方法的时候都需要执行同步操作，那么有没有方法可以避免这一个缺点呢？这个时候我们就可以用双检锁的模式了：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> DoubleCheckSingleton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">){ </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//第一层检查</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">){ </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//第二层检查</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">                instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要彻底理解双检锁模式的原理，首先要明白在Java里面一个线程对共享变量的修改，对于另外一个线程是不可预知的，也就是说它可能看不到变化，也有可能会看到，虽然在大多数时候是看不到的，但这不能证明它总是会被看到，除非正确的使用同步，否则是没法掌控的。</p><p>关于双检锁里面为什么必须要加volatile关键字，主要用来避免重排序问题导致其他的线程看到了一个已经分配内存和地址但没有初始化的对象，也就是说这个对象还不是处于可用状态，就被其他线程引用了。</p><p>下面的代码在多线程环境下不是原子执行的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DoubleCheckSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>正常的底层执行顺序会转变成三步：</p><ol><li>给DoubleCheckSingleton类的实例instance分配内存</li><li>调用实例instance的构造函数来初始化成员变量</li><li>将instance指向分配的内存地址</li></ol><p>上面的三步，无论在 A 线程当前执行到那一步骤，对 B 线程来说可能看到A的状态只能是两种，1、2看到的都是 null，3 看到的非 null，这是没问题的。</p><p>但是如果线程 A 在重排序的情况下，上面的执行顺序会变成 1,3,2。现在假设 A 线程按 1,3,2三个步骤顺序执行，当执行到第二步的时候。B线程开始调用这个方法，那么在第一个 null 的检查的时候，就有可能看到这个实例不是 null，然后直接返回这个实例开始使用，但其实是有问题的，因为对象还没有初始化，状态还处于不可用的状态，故而会导致异常发生。</p><p>要解决这个问题，可以通过 <code>volatile</code> 关键词来避免指令重排序，这里相比可见性问题主要是为了避免重排序问题。如果使用了 volatile 修饰成员变量，那么在变量赋值之后，会有一个内存屏障。也就说只有执行完 1,2,3 步操作后，读取操作才能看到，读操作不会被重排序到写操作之前。这样以来就解决了对象状态不完整的问题。</p><p>那么 volatile 到底如何保证可见性和禁止指令重排序的</p><p></p><div class="hint-container tip"><p class="hint-container-title">在《深入理解Java虚拟机》一书中有描述：</p><p>“观察加入 <code>volatile</code> 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 <code>lock</code> 前缀指令”</p></div><p>lock 前缀指令实际上相当于一个<code>内存屏障</code>（也成内存栅栏），内存屏障会提供 3 个功能：</p><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li></ol><p>从上面可以看到 volatile <code>不保证原子性，保证可见性和部分有序性</code>，这一点需要谨记。</p><blockquote><p>此外这里需要注意的是在 JDK5 之前，就算加了 volatile 关键字也依然有问题，原因是之前的JMM模型是有缺陷，volatile 变量前后的代码仍然可以出现重排序问题，这个问题在 JDK5 之后才得到解决，所以现在才可以这么使用。</p></blockquote><p>正是因为双检锁的单例模式涉及的底层知识比较多，所以在面试中也是经常被问的一个话题。</p><h2 id="其他的单例实现" tabindex="-1"><a class="header-anchor" href="#其他的单例实现"><span>其他的单例实现</span></a></h2><h3 id="静态内部类实现" tabindex="-1"><a class="header-anchor" href="#静态内部类实现"><span>静态内部类实现</span></a></h3><p>前面说到过，单例模式从创建方式来说有懒汉（延迟加载）和非懒汉就是饿汉的单例模式。关于懒汉模式的除了双检锁模式，还有通过静态内部类实现的如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> HolderFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Holder</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Holder</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态内部类是由JVM内部的锁机制来保证不会创建多个实例，非常巧妙的避开了多线程问题。</p><h3 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式"><span>饿汉式</span></a></h3><p>关于饿汉的单例模式形象点说，就是我不管你到底用不用得到都提前给你准备好。相比懒汉需要考虑各种线程问题，饿汉就比较简单了，第一种，非常简单：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  SimpleSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> ourInstance </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> SimpleSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> SimpleSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> SimpleSingleton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> ourInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="基于枚举方式" tabindex="-1"><a class="header-anchor" href="#基于枚举方式"><span>基于枚举方式：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> EnumSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    SINGLETON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于枚举的方式非常简洁，而且非常安全由jvm内部保证，自带私有的构造方法并且序列化和反射都不会破坏单例的安全性，据说是JDK5之后最好的单例创建方式，这个具体还是分应用场景。</p><h2 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>REF</span></a></h2><p><a href="https://cloud.tencent.com/developer/article/1161095" target="_blank" rel="noopener noreferrer">Java单例模式之双检锁深入思考</a></p>`,43),h=[t];function p(k,d){return a(),s("div",null,h)}const g=i(l,[["render",p],["__file","java_double_check_single_instance.html.vue"]]),o=JSON.parse('{"path":"/java/concurrency/java_double_check_single_instance.html","title":"深入 Java 单例模式双检锁涉及到的线程安全","lang":"zh-CN","frontmatter":{"title":"深入 Java 单例模式双检锁涉及到的线程安全","author":"Evan","editLink":false,"comment":false,"tag":["Java"],"date":"2025-03-24T00:00:00.000Z","description":"前言 单例模式在Java开发中是非常经典和实用的一种设计模式，在JDK的内部包的好多api都采用了单例模式，如我们熟悉的Runtime类. 单例模式总的来说有两种创建方式，一种是延迟加载的模式，一种是非延迟加载的模式，今天我们来学习一下基于双检锁延迟加载的单例模式。 什么是单例模式 顾名思义，单例模式指的是在整个程序运行期间，我们只能初始化某个类一次，...","head":[["meta",{"property":"og:url","content":"https://leslie-dd.github.io/leslie-blog/leslie-blog/java/concurrency/java_double_check_single_instance.html"}],["meta",{"property":"og:site_name","content":"Leslie的博客"}],["meta",{"property":"og:title","content":"深入 Java 单例模式双检锁涉及到的线程安全"}],["meta",{"property":"og:description","content":"前言 单例模式在Java开发中是非常经典和实用的一种设计模式，在JDK的内部包的好多api都采用了单例模式，如我们熟悉的Runtime类. 单例模式总的来说有两种创建方式，一种是延迟加载的模式，一种是非延迟加载的模式，今天我们来学习一下基于双检锁延迟加载的单例模式。 什么是单例模式 顾名思义，单例模式指的是在整个程序运行期间，我们只能初始化某个类一次，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-23T19:00:21.000Z"}],["meta",{"property":"article:author","content":"Evan"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2025-03-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-23T19:00:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深入 Java 单例模式双检锁涉及到的线程安全\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-23T19:00:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Evan\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"什么是单例模式","slug":"什么是单例模式","link":"#什么是单例模式","children":[]},{"level":2,"title":"基于双检锁的单例模式","slug":"基于双检锁的单例模式","link":"#基于双检锁的单例模式","children":[]},{"level":2,"title":"其他的单例实现","slug":"其他的单例实现","link":"#其他的单例实现","children":[{"level":3,"title":"静态内部类实现","slug":"静态内部类实现","link":"#静态内部类实现","children":[]},{"level":3,"title":"饿汉式","slug":"饿汉式","link":"#饿汉式","children":[]},{"level":3,"title":"基于枚举方式：","slug":"基于枚举方式","link":"#基于枚举方式","children":[]}]},{"level":2,"title":"REF","slug":"ref","link":"#ref","children":[]}],"git":{"createdTime":1742756421000,"updatedTime":1742756421000,"contributors":[{"name":"Leslie","email":"LeslieDYF@gmail.com","commits":1}]},"readingTime":{"minutes":6.17,"words":1850},"filePathRelative":"java/concurrency/java_double_check_single_instance.md","localizedDate":"2025年3月24日","excerpt":"<p></p>\\n<h2>前言</h2>\\n<p>单例模式在Java开发中是非常经典和实用的一种设计模式，在JDK的内部包的好多api都采用了单例模式，如我们熟悉的Runtime类.</p>\\n<p>单例模式总的来说有两种创建方式，一种是延迟加载的模式，一种是非延迟加载的模式，今天我们来学习一下基于双检锁延迟加载的单例模式。</p>\\n<h2>什么是单例模式</h2>\\n<p>顾名思义，单例模式指的是在整个程序运行期间，我们只能初始化某个类一次，然后一直使用这个实例，尤其是在多线程的环境下，也要保证如此。</p>\\n<h2>基于双检锁的单例模式</h2>\\n<p>在介绍基于双检锁的单例模式下，我们先思考下如何在使用延迟加载的情况下实现一个单例模式，可能有一些比较年轻的小伙伴，不假思索的就写下了下面的一段代码：</p>","autoDesc":true}');export{g as comp,o as data};
