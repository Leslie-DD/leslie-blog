import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as e}from"./app-C4IA4XLb.js";const l="/leslie-blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84-C6j3LIAP.png",n="/leslie-blog/assets/MESI%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BC%93%E5%AD%98%E7%8A%B6%E6%80%81%E6%9C%BA-BpM6Qapw.png",t={},r=e('<p>内存屏障是硬件之上、操作系统或JVM之下，对并发作出的最后一层支持。再向下是是硬件提供的支持；向上是操作系统或JVM对内存屏障作出的各种封装。内存屏障是一种标准，各厂商可能采用不同的实现。</p><p>本文仅为了帮助理解JVM提供的并发机制。首先，从volatile的语义引出可见性与重排序问题；接下来，阐述问题的产生原理，了解为什么需要内存屏障；然后，浅谈内存屏障的标准、厂商对内存屏障的支持，并以volatile为例讨论内存屏障如何解决这些问题；最后，补充介绍JVM在内存屏障之上作出的几个封装。为了帮助理解，会简要讨论硬件架构层面的一些基本原理（特别是CPU架构），但不会深入实现机制。</p><blockquote><p>内存屏障的实现涉及大量硬件架构层面的知识，又需要操作系统或JVM的配合才能发挥威力，单纯从任何一个层面都无法理解。本文整合了这三个层面的大量知识，篇幅较长，希望能在一篇文章内，把内存屏障的基本问题讲述清楚。</p><p>如有疏漏，还望指正！</p></blockquote><h2 id="volatile变量规则" tabindex="-1"><a class="header-anchor" href="#volatile变量规则"><span><a href="#volatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99" title="volatile变量规则"></a>volatile变量规则</span></a></h2><p>一个用于引出内存屏障的好例子是<code>volatile变量规则</code>。</p><p>volatile关键字可参考猴子刚开博客时的文章<a href="https://monkeysayhi.github.io/2016/11/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener noreferrer">volatile关键字的作用、原理</a>。volatile变量规则描述了volatile变量的<strong>偏序</strong>语义；这里从volatile变量规则的角度来讲解，顺便做个复习。</p><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span><a href="#%E5%AE%9A%E4%B9%89" title="定义"></a>定义</span></a></h2><p>volatile变量规则：<strong>对volatile变量的写入操作必须在对该变量的读操作之前执行</strong>。</p><p>volatile变量规则只是一种标准，要求JVM实现保证volatile变量的偏序语义。<strong>结合程序顺序规则、传递性</strong>，该偏序语义通常表现为两个作用：</p><ul><li>保持可见性</li><li>禁用重排序（读操作禁止重排序之后的操作，写操作禁止重排序之前的操作）</li></ul><blockquote><p>补充：</p><ul><li>程序顺序规则：如果程序中操作A在操作B之前，那么在线程中操作A将在操作B之前执行。</li><li>传递性：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。</li></ul></blockquote><p>后文，如果仅涉及可见性，则指明“可见性”；如果二者均涉及，则以“偏序”代称。重排序一定会带来可见性问题，因此，不会出现单独讨论重排序的场景。</p><h2 id="正确姿势" tabindex="-1"><a class="header-anchor" href="#正确姿势"><span><a href="#%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF" title="正确姿势"></a>正确姿势</span></a></h2><p>之前的文章多次涉及volatile变量规则的用法。</p><p>简单的仅利用volatile变量规则对volatile变量本身的可见性保证：</p><ul><li><a href="https://monkeysayhi.github.io/2017/09/27/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/" target="_blank" rel="noopener noreferrer">面试中单例模式有几种写法？</a>：“饱汉 - 变种 3”在DCL的基础上，使用volatile修饰单例，以保证单例的可见性。</li></ul><p>复杂的利用volatile变量规则（结合了程序顺序规则、传递性）保证变量本身及周围其他变量的偏序：</p><ul><li><a href="https://monkeysayhi.github.io/2017/12/05/%E6%BA%90%E7%A0%81%7C%E5%B9%B6%E5%8F%91%E4%B8%80%E6%9E%9D%E8%8A%B1%E4%B9%8BReentrantLock%E4%B8%8EAQS%EF%BC%881%EF%BC%89%EF%BC%9Alock%E3%80%81unlock/" target="_blank" rel="noopener noreferrer">源码|并发一枝花之ReentrantLock与AQS（1）：lock、unlock</a>：exclusiveOwnerThread借助于volatile变量state保证其相对于state的偏序。</li><li><a href="https://monkeysayhi.github.io/2017/10/24/%E6%BA%90%E7%A0%81%7C%E5%B9%B6%E5%8F%91%E4%B8%80%E6%9E%9D%E8%8A%B1%E4%B9%8BCopyOnWriteArrayList/" target="_blank" rel="noopener noreferrer">源码|并发一枝花之CopyOnWriteArrayList</a>：CopyOnWriteArrayList借助于volatile变量array，对外提供偏序语义。</li></ul><h2 id="可见性与重排序" tabindex="-1"><a class="header-anchor" href="#可见性与重排序"><span><a href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E9%87%8D%E6%8E%92%E5%BA%8F" title="可见性与重排序"></a>可见性与重排序</span></a></h2><p>前文多次提到可见性与重排序的问题，内存屏障的存在就是为了解决这些问题。到底什么是可见性？什么是重排序？为什么会有这些问题？</p><h2 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性"><span><a href="#%E5%8F%AF%E8%A7%81%E6%80%A7" title="可见性"></a>可见性</span></a></h2><h3 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1"><span><a href="#%E5%AE%9A%E4%B9%89-1" title="定义"></a>定义</span></a></h3><p>可见性的定义常见于各种并发场景中，以多线程为例：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。</p><p>从性能角度考虑，没有必要在修改后就立即同步修改的值——如果多次修改后才使用，那么只需要最后一次同步即可，在这之前的同步都是性能浪费。因此，实际的可见性定义要弱一些，只需要保证：<strong>当一个线程修改了线程共享变量的值，其它线程在使用前，能够得到最新的修改值</strong>。</p><blockquote><p>可见性可以认为是最弱的“<code>一致性</code>”（<code>弱一致</code>），只保证用户见到的数据是一致的，但不保证任意时刻，存储的数据都是一致的（<code>强一致</code>）。下文会讨论“缓存可见性”问题，部分文章也会称为“缓存一致性”问题。</p></blockquote><h3 id="问题来源" tabindex="-1"><a class="header-anchor" href="#问题来源"><span><a href="#%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90" title="问题来源"></a>问题来源</span></a></h3><p>一个最简单的可见性问题来自计算机内部的缓存架构：</p><p><img src="'+l+'" alt="计算机内部的缓存架构"></p><p>缓存大大缩小了高速CPU与低速内存之间的差距。以三层缓存架构为例：</p><ul><li>L1 Cache最接近CPU, 容量最小（如32K、64K等）、速度最高，每个核上都有一个L1 Cache。</li><li>L2 Cache容量更大（如256K）、速度更低, 一般情况下，每个核上都有一个独立的L2 Cache。</li><li>L3 Cache最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。</li></ul><blockquote><p>准确地说，每个核上有两个L1 Cache, 一个存数据 L1d Cache, 一个存指令 L1i Cache。</p></blockquote><p>单核时代的一切都是那么完美。然而，多核时代出现了可见性问题。一个badcase如下：</p><ol><li>Core0与Core1命中了内存中的同一个地址，那么各自的L1 Cache会缓存同一份数据的副本。</li><li>最开始，Core0与Core1都在友善的读取这份数据。</li><li>突然，Core0要使坏了，它修改了这份数据，使得两份缓存中的数据不同了，更确切的说，Core1 L1 Cache中的数据<code>失效</code>了。</li></ol><p>单核时代只有Core0，Core0修改Core0读，没什么问题；但是，现在<em>Core0修改后，Core1并不知道数据已经失效，继续傻傻的使用</em>，轻则数据计算错误，重则导致死循环、程序崩溃等。</p><p>实际的可见性问题还要扩展到两个方向：</p><ul><li>除三级缓存外，<em>各厂商实现的硬件架构中还存在多种多样的缓存，都存在类似的可见性问题</em>。例如，寄存器就相当于CPU与L1 Cache之间的缓存。</li><li>各种高级语言（包括Java）的多线程内存模型中，<em>在线程栈内自己维护一份缓存是常见的优化措施，但显然在CPU级别的缓存可见性问题面前，一切都失效了</em>。</li></ul><blockquote><p>以上只是最简单的可见性问题，不涉及重排序等。</p><p>重排序也会导致可见性问题；同时，缓存上的可见性也会引起一些看似重排序导致的问题。</p></blockquote><h2 id="重排序" tabindex="-1"><a class="header-anchor" href="#重排序"><span><a href="#%E9%87%8D%E6%8E%92%E5%BA%8F" title="重排序"></a>重排序</span></a></h2><h3 id="定义-2" tabindex="-1"><a class="header-anchor" href="#定义-2"><span><a href="#%E5%AE%9A%E4%B9%89-2" title="定义"></a>定义</span></a></h3><p>重排序并没有严格的定义。整体上可以分为两种：</p><ul><li>真·重排序：<strong>编译器、底层硬件（CPU等）出于“优化”的目的</strong>，按照某种规则将指令重新排序（尽管有时候看起来像乱序）。</li><li>伪·重排序：由于<strong>缓存同步顺序</strong>等问题，看起来指令被重排序了。</li></ul><p>重排序也是单核时代非常优秀的优化手段，有足够多的措施保证其在单核下的正确性。在多核时代，如果工作线程之间不共享数据或仅共享不可变数据，重排序也是性能优化的利器。然而，如果工作线程之间共享了可变数据，由于两种重排序的结果都不是固定的，会导致工作线程似乎表现出了随机行为。</p><blockquote><p>第一次接触重排序的概念一定很迷糊，耐心，耐心。</p></blockquote><h3 id="问题来源-1" tabindex="-1"><a class="header-anchor" href="#问题来源-1"><span><a href="#%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90-1" title="问题来源"></a>问题来源</span></a></h3><p>重排序问题无时无刻不在发生，源自三种场景：</p><ol><li>编译器编译时的优化</li><li>处理器执行时的乱序优化</li><li>缓存同步顺序（导致可见性问题）</li></ol><p>场景1、2属于真·重排序；场景3属于伪·重排序。场景3也属于可见性问题，为保持连贯性，我们先讨论场景3。</p><h4 id="可见性导致的伪·重排序" tabindex="-1"><a class="header-anchor" href="#可见性导致的伪·重排序"><span><a href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BC%AA%C2%B7%E9%87%8D%E6%8E%92%E5%BA%8F" title="可见性导致的伪·重排序"></a>可见性导致的伪·重排序</span></a></h4><p>缓存同步顺序本质上是可见性问题。</p><p>假设<code>程序顺序</code>（program order）中先更新变量v1、再更新变量v2，不考虑真·重排序：</p><ol><li>Core0先更新缓存中的v1，再更新缓存中的v2（位于两个缓存行，这样淘汰缓存行时不会一起写回内存）。</li><li>Core0读取v1（假设使用LRU协议淘汰缓存）。</li><li>Core0的缓存满，将最远使用的v2写回内存。</li><li>Core1的缓存中本来存有v1，现在将v2加载入缓存。</li></ol><blockquote><p>重排序是针对程序顺序而言的，如果指令执行顺序与程序顺序不同，就说明这段指令被重排序了。</p></blockquote><p>此时，<em>尽管“更新v1”的事件早于“更新v2”发生，但Core1只看到了v2的最新值，却看不到v1的最新值</em>。这属于可见性导致的<strong>伪·重排序：虽然没有实际上没有重排序，但看起来发生了重排序</strong>。</p><p>可以看到，缓存可见性不仅仅导致可见性问题，还会导致伪·重排序。因此，<em>只要解决了缓存上的可见性问题，也就解决了伪·重排序</em>。</p><h5 id="mesi协议" tabindex="-1"><a class="header-anchor" href="#mesi协议"><span><a href="#MESI%E5%8D%8F%E8%AE%AE" title="MESI协议"></a>MESI协议</span></a></h5><p>回到可见性问题中的例子和可见性的定义。要解决这个问题很简单，套用可见性的定义，只需要：<em>在Core0修改了数据v后，让Core1在使用v前，能得到v最新的修改值</em>。</p><p>这个要求很弱，既可以在每次修改v后，都同步修改值到其他缓存了v的Cache中；又可以只同步使用前的最后一次修改值。后者性能上更优，如何实现呢：</p><ol><li>Core0修改v后，发送一个信号，将Core1缓存的v标记为失效，并将修改值写回内存。</li><li>Core0可能会多次修改v，每次修改都只发送一个信号（发信号时会锁住缓存间的总线），Core1缓存的v保持着失效标记。</li><li>Core1使用v前，发现缓存中的v已经失效了，得知v已经被修改了，于是重新从其他缓存或内存中加载v。</li></ol><p>以上即是MESI（Modified Exclusive Shared Or Invalid，缓存的四种状态）协议的基本原理，不算严谨，但对于理解缓存可见性（更常见的称呼是“缓存一致性”）已经足够。</p><p>MESI协议解决了CPU缓存层面的可见性问题。</p><blockquote><p>以下是MESI协议的缓存状态机，简单看看即可：</p><p><img src="'+n+`" alt="MESI协议的缓存状态机"></p><p>状态：</p><ul><li>M（修改, Modified）: 本地处理器已经修改缓存行, 即是脏行, 它的内容与内存中的内容不一样. 并且此cache只有本地一个拷贝（专有）。</li><li>E（专有, Exclusive）: 缓存行内容和内存中的一样, 而且其它处理器都没有这行数据。</li><li>S（共享, Shared）: 缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝。</li><li>I（无效, Invalid）: 缓存行失效, 不能使用。</li></ul></blockquote><h5 id="剩余问题" tabindex="-1"><a class="header-anchor" href="#剩余问题"><span><a href="#%E5%89%A9%E4%BD%99%E9%97%AE%E9%A2%98" title="剩余问题"></a>剩余问题</span></a></h5><p>既然有了MESI协议，是不是就不需要volatile的可见性语义了？当然不是，还有三个问题：</p><ul><li><strong>并不是所有的硬件架构都提供了相同的一致性保证，JVM需要volatile统一语义</strong>（就算是MESI，也只解决CPU缓存层面的问题，没有涉及其他层面）。</li><li>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</li><li>如果不考虑真·重排序，MESI确实解决了CPU缓存层面的可见性问题；然而，真·重排序也会导致可见性问题。</li></ul><blockquote><p>暂时第一个问题称为“<code>内存可见性</code>”问题，内存屏障解决了该问题。后文讨论。</p></blockquote><h4 id="编译器编译时的优化" tabindex="-1"><a class="header-anchor" href="#编译器编译时的优化"><span><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E6%97%B6%E7%9A%84%E4%BC%98%E5%8C%96" title="编译器编译时的优化"></a>编译器编译时的优化</span></a></h4><blockquote><p>JVM自己维护的内存模型中也有可见性问题，使用volatile做标记，取消volatile变量的缓存，就解决了JVM层面的可见性问题。编译器产生的重排序也采用了同样的思路。</p></blockquote><p>编译器为什么要重排序（re-order）呢？和处理器乱序执行的目的是一样的：与其等待阻塞指令（如等待缓存刷入）完成，不如先去执行其他指令。与处理器乱序执行相比，编译器重排序能够完成更大范围、效果更好的乱序优化。</p><blockquote><p>由于同处理器乱序执行的目的相同，原理相似，这里不讨论编译器重排序的实现原理。</p></blockquote><p>幸运的是，既然是编译器层面的重排序，自然可以由编译器控制。使用volatile做标记，就可以禁用编译器层面的重排序。</p><h4 id="处理器执行时的乱序优化" tabindex="-1"><a class="header-anchor" href="#处理器执行时的乱序优化"><span><a href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E4%B9%B1%E5%BA%8F%E4%BC%98%E5%8C%96" title="处理器执行时的乱序优化"></a>处理器执行时的乱序优化</span></a></h4><p>处理器层面的乱序优化节省了大量等待时间，提高了处理器的性能。</p><p>所谓“乱序”只是被叫做“乱序”，实际上也遵循着一定规则：只要两个指令之间不存在数据依赖，就可以对这两个指令乱序。不必关心数据依赖的精确定义，可以理解为：<strong>只要不影响程序单线程、顺序执行的结果，就可以对两个指令重排序</strong>。</p><blockquote><p>不进行乱序优化时，处理器的指令执行过程如下：</p><ol><li>指令获取。</li><li>如果输入的运算对象是可以获取的（比如已经存在于寄存器中），这条指令会被发送到合适的功能单元。如果一个或者更多的运算对象在当前的时钟周期中是不可获取的（通常需要从主内存获取），处理器会开始等待直到它们是可以获取的。</li><li>指令在合适的功能单元中被执行。</li><li>功能单元将运算结果写回寄存器。</li></ol><p>乱序优化下的执行过程如下：</p><ol><li>指令获取。</li><li>指令被发送到一个指令序列（也称<code>执行缓冲区</code>或者<code>保留站</code>）中。</li><li><strong>指令将在序列中等待，直到它的数据运算对象是可以获取的。然后，指令被允许在先进入的、旧的指令之前离开序列缓冲区</strong>。（此处表现为乱序）</li><li>指令被分配给一个合适的功能单元并由之执行。</li><li>结果被放到一个序列中。</li><li>仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器中。（重整乱序结果）</li></ol><p>当然，为了实现乱序优化，还需要很多技术的支持，如<code>寄存器重命名</code>、<code>分枝预测</code>等，但大致了解到这里就足够。后文的注释中会据此给出内存屏障的实现方案。</p></blockquote><p>乱序优化在单核时代不影响正确性；但多核时代的多线程能够在不同的核上实现真正的并行，一旦线程间共享数据，就出现问题了。看一段很经典的代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> OutofOrderExecution</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> InterruptedException</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> t1</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                a </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                x </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> t2</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                b </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">                y </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        t1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        t2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(“(” </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> “,” </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> “)”);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>不考虑编译器重排序和缓存可见性问题</em>，上面的代码可能会输出什么呢？</p><p>最容易想到的结果是<code>(0,1)</code>、<code>(1,0)</code>或<code>(1,1)</code>。因为可能先后执行线程t1、t2，也可能反之，还可能t1、t2交替执行。</p><p>然而，<em>这段代码的执行结果也可能是(0,0)</em>，看起来违反常理。这是处理器乱序执行的结果：线程t1内部的两行代码之间不存在数据依赖，因此，可以将<code>x = b</code>乱序到<code>a = 1</code>前；同时，线程t2中的<code>y = a</code>早于线程t1中的<code>a = 1</code>执行。一个可能的执行序列如下：</p><ol><li>t1: x = b</li><li>t2: b = 1</li><li>t2: y = a</li><li>t1: a = 1</li></ol><blockquote><p>这里将代码等同于指令，不严谨，但不妨碍理解。</p></blockquote><p>看起来，似乎将上述重排序（或乱序）导致的问题称为“可见性”问题也未尝不可。然而，这种重排序的危害要远远大于单纯的可见性，因为并不是所有的指令都是简单的读或者写——<a href="https://monkeysayhi.github.io/2017/09/27/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/" target="_blank" rel="noopener noreferrer">面试中单例模式有几种写法？</a>与<a href="https://monkeysayhi.github.io/2016/11/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener noreferrer">volatile关键字的作用、原理</a>中都提到了<code>部分初始化</code>的例子，这种<code>不安全发布</code>就是由于重排序导致的。因此，<strong>将重排序归为“可见性”问题并不合适，只能说重排序会导致可见性问题</strong>。</p><p>也就是说，单纯解决内存可见性问题是不够的，还<strong>需要专门解决<code>处理器重排序</code>的问题</strong>。</p><blockquote><p>当然，某些处理器不会对指令乱序，或能够基于多核间的数据依赖乱序。这时，volatile仅用于统一重排序方面的语义。</p></blockquote><h2 id="内存屏障" tabindex="-1"><a class="header-anchor" href="#内存屏障"><span><a href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" title="内存屏障"></a>内存屏障</span></a></h2><blockquote><p>内存屏障（Memory Barrier）与内存栅栏（Memory Fence）是同一个概念，不同的叫法。</p></blockquote><p>通过<strong>volatile标记，可以解决编译器层面的可见性与重排序问题</strong>。而<strong>内存屏障则解决了硬件层面的可见性与重排序问题</strong>。</p><blockquote><p>猴子暂时没有验证下述分析，仅从逻辑和系统设计考量上进行了判断、取舍。以后会补上实验。</p></blockquote><h2 id="标准" tabindex="-1"><a class="header-anchor" href="#标准"><span><a href="#%E6%A0%87%E5%87%86" title="标准"></a>标准</span></a></h2><p>先简单了解两个指令：</p><ul><li>Store：将处理器缓存的数据刷新到内存中。</li><li>Load：将内存存储的数据拷贝到处理器的缓存中。</li></ul><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load2</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p><p>然而，<strong>除了mfence，不同的CPU架构对内存屏障的实现方式与实现程度非常不一样</strong>。相对来说，Intel CPU的<code>强内存模型</code>比DEC Alpha的<code>弱复杂内存模型</code>（缓存不仅分层了，还分区了）更简单。x86架构是在多线程编程中最常见的，下面讨论x86架构中内存屏障的实现。</p><blockquote><p>查阅资料时，你会发现每篇讲内存屏障的文章讲的都不同。不过，重要的是理解基本原理，需要的时候再继续深究即可。</p><p>不过不管是那种方案，<strong>内存屏障的实现都要针对乱序执行的过程来设计</strong>。前文的注释中讲解了乱序执行的基本原理：核心是一个<strong>序列缓冲区</strong>，只要指令的数据运算对象是可以获取的，指令就被允许在先进入的、旧的指令之前离开序列缓冲区，开始执行。对于内存可见性的语义，内存屏障可以通过使用类似MESI协议的思路实现。对于重排序语义的实现机制，猴子没有继续研究，一种可行的思路是：</p><ul><li>当CPU收到屏障指令时，不将屏障指令放入序列缓冲区，而将屏障指令及后续所有指令放入一个FIFO队列中（指令是按批发送的，不然没有乱序的必要）</li><li>允许乱序执行完序列缓冲区中的所有指令</li><li>从FIFO队列中取出屏障指令，执行（并刷新缓存等，实现内存可见性的语义）</li><li>将FIFO队列中的剩余指令放入序列缓冲区</li><li>恢复正常的乱序执行</li></ul><p>对于x86架构中的sfence屏障指令而言，则保证sfence之前的store执行完，再执行sfence，最后执行sfence之后的store；除了禁用sfence前后store乱序带来的新的数据依赖外，不影响load命令的乱序。详细见后。</p></blockquote><h2 id="x86架构的内存屏障" tabindex="-1"><a class="header-anchor" href="#x86架构的内存屏障"><span><a href="#x86%E6%9E%B6%E6%9E%84%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" title="x86架构的内存屏障"></a>x86架构的内存屏障</span></a></h2><p>x86架构并没有实现全部的内存屏障。</p><h3 id="store-barrier" tabindex="-1"><a class="header-anchor" href="#store-barrier"><span><a href="#Store-Barrier" title="Store Barrier"></a>Store Barrier</span></a></h3><p>sfence指令实现了Store Barrier，相当于StoreStore Barriers。</p><p>强制所有在sfence指令之前的store指令，都在该sfence指令执行之前被执行，发送缓存失效信号，并把store buffer中的数据刷出到CPU的L1 Cache中；所有在sfence指令之后的store指令，都在该sfence指令执行之后被执行。即，禁止对sfence指令前后store指令的重排序跨越sfence指令，使<strong>所有Store Barrier之前发生的内存更新都是可见的</strong>。</p><p>这里的“可见”，指<strong>修改值可见</strong>（内存可见性）且<strong>操作结果可见</strong>（禁用重排序）。下同。</p><blockquote><p>内存屏障的标准中，讨论的是缓存与内存间的<code>相干性</code>，实际上，同样适用于寄存器与缓存、甚至寄存器与内存间等多级缓存之间。x86架构使用了MESI协议的一个变种，由协议保证三层缓存与内存间的相关性，则内存屏障只需要保证store buffer（可以认为是寄存器与L1 Cache间的一层缓存）与L1 Cache间的相干性。下同。</p></blockquote><h3 id="load-barrier" tabindex="-1"><a class="header-anchor" href="#load-barrier"><span><a href="#Load-Barrier" title="Load Barrier"></a>Load Barrier</span></a></h3><p>lfence指令实现了Load Barrier，相当于LoadLoad Barriers。</p><p>强制所有在lfence指令之后的load指令，都在该lfence指令执行之后被执行，并且一直等到load buffer被该CPU读完才能执行之后的load指令（发现缓存失效后发起的刷入）。即，禁止对lfence指令前后load指令的重排序跨越lfence指令，配合Store Barrier，使<strong>所有Store Barrier之前发生的内存更新，对Load Barrier之后的load操作都是可见的</strong>。</p><h3 id="full-barrier" tabindex="-1"><a class="header-anchor" href="#full-barrier"><span><a href="#Full-Barrier" title="Full Barrier"></a>Full Barrier</span></a></h3><p>mfence指令实现了Full Barrier，相当于StoreLoad Barriers。</p><p>mfence指令综合了sfence指令与lfence指令的作用，强制所有在mfence指令之前的store/load指令，都在该mfence指令执行之前被执行；所有在mfence指令之后的store/load指令，都在该mfence指令执行之后被执行。即，禁止对mfence指令前后store/load指令的重排序跨越mfence指令，使<strong>所有Full Barrier之前发生的操作，对所有Full Barrier之后的操作都是可见的。</strong></p><h2 id="volatile如何解决内存可见性与处理器重排序问题" tabindex="-1"><a class="header-anchor" href="#volatile如何解决内存可见性与处理器重排序问题"><span><a href="#volatile%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98" title="volatile如何解决内存可见性与处理器重排序问题"></a>volatile如何解决内存可见性与处理器重排序问题</span></a></h2><blockquote><p>在编译器层面，仅将volatile作为标记使用，取消编译层面的缓存和重排序。</p></blockquote><p>如果硬件架构本身已经保证了内存可见性（如单核处理器、一致性足够的内存模型等），那么volatile就是一个空标记，不会插入相关语义的内存屏障。</p><p>如果硬件架构本身不进行处理器重排序、有更强的重排序语义（能够分析多核间的数据依赖）、或在单核处理器上重排序，那么volatile就是一个空标记，不会插入相关语义的内存屏障。</p><p>如果不保证，仍以x86架构为例，JVM对volatile变量的处理如下：</p><ul><li>在写volatile变量v之后，插入一个sfence。这样，sfence之前的所有store（包括写v）不会被重排序到sfence之后，sfence之后的所有store不会被重排序到sfence之前，禁用跨sfence的store重排序；且sfence之前修改的值都会被写回缓存，并标记其他CPU中的缓存失效。</li><li>在读volatile变量v之前，插入一个lfence。这样，lfence之后的load（包括读v）不会被重排序到lfence之前，lfence之前的load不会被重排序到lfence之后，禁用跨lfence的load重排序；且lfence之后，会首先刷新无效缓存，从而得到最新的修改值，与sfence配合保证内存可见性。</li></ul><blockquote><p>在另外一些平台上，JVM使用mfence代替sfence与lfence，实现更强的语义。</p></blockquote><p>二者结合，共同实现了Happens-Before关系中的volatile变量规则。</p><h2 id="jvm对内存屏障作出的其他封装" tabindex="-1"><a class="header-anchor" href="#jvm对内存屏障作出的其他封装"><span><a href="#JVM%E5%AF%B9%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E4%BD%9C%E5%87%BA%E7%9A%84%E5%85%B6%E4%BB%96%E5%B0%81%E8%A3%85" title="JVM对内存屏障作出的其他封装"></a>JVM对内存屏障作出的其他封装</span></a></h2><p>除volatile外，常见的JVM实现还基于内存屏障作了一些其他封装。<strong>借助于内存屏障，这些封装也得到了内存屏障在可见性与重排序上的语义</strong>。</p><blockquote><p>借助：piggyback。</p><p>在JVM中，借助通常指：将Happens-Before的程序顺序规则与其他某个顺序规则（通常是监视器锁规则、volatile变量规则）结合起来，从而对某个未被锁保护的变量的访问操作进行排序。</p><p>本文将借助的语义扩展到更大的范围，可以借助任何现有机制，以获得现有机制的某些属性。当然，并不是所有属性都能被借助，比如原子性。但基于前文对内存屏障的分析可知，可见性与重排序是可以被借助的。</p></blockquote><p>下面仍基于x86架构讨论。</p><h2 id="final关键字" tabindex="-1"><a class="header-anchor" href="#final关键字"><span><a href="#final%E5%85%B3%E9%94%AE%E5%AD%97" title="final关键字"></a>final关键字</span></a></h2><p>如果一个实例的字段被声明为final，则JVM会在初始化final变量后插入一个sfence。</p><blockquote><p>类的final字段在<code>&lt;clinit&gt;()</code>方法中初始化，其可见性由JVM的类加载过程保证。</p></blockquote><p>final字段的初始化在<code>&lt;init&gt;()</code>方法中完成。sfence禁用了sfence前后对store的重排序，且保证final字段初始化之前（include）的内存更新都是可见的。</p><h3 id="再谈部分初始化" tabindex="-1"><a class="header-anchor" href="#再谈部分初始化"><span><a href="#%E5%86%8D%E8%B0%88%E9%83%A8%E5%88%86%E5%88%9D%E5%A7%8B%E5%8C%96" title="再谈部分初始化"></a>再谈部分初始化</span></a></h3><p>上述良好性质被称为“<code>初始化安全性</code>”。它保证，<strong>对于被正确构造的对象，所有线程都能看到构造函数给对象的各个final字段设置的正确值，而不管采用何种方式来发布对象</strong>。</p><blockquote><p><strong>这里将可见性从“final字段初始化之前（include）的内存更新”缩小到“final字段初始化”</strong>。猴子没找到确切的原因，手里暂时只有一个jdk也不方便验证。可能是因为，<em>JVM没有要求虚拟机实现在生成<code>&lt;init&gt;()</code>方法时编排字段初始化指令的顺序</em>。</p></blockquote><p>初始化安全性为解决部分初始化问题带来了新的思路：如果待发布对象的所有域都是final修饰的，那么可以防止对对象的初始引用被重排序到构造过程完成之前。于是，<a href="https://monkeysayhi.github.io/2017/09/27/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/" target="_blank" rel="noopener noreferrer">面试中单例模式有几种写法？</a>中的饱汉变种三还可以扔掉volatile，改为借助final的sfence语义：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 饱汉</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// ThreadSafe</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Singleton1_3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Singleton1_3</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> f1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   // 触发部分初始化问题</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> f2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Singleton1_3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Singleton1_3</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Singleton1_3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // must be a complete instance</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">          singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Singleton1_3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> singleton;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意，初始化安全性仅针对安全发布中的部分初始化问题，与其他安全发布问题、发布后的可见性问题无关。</p></blockquote><h2 id="cas" tabindex="-1"><a class="header-anchor" href="#cas"><span><a href="#CAS" title="CAS"></a>CAS</span></a></h2><p>在x86架构上，CAS被翻译为”<code>lock cmpxchg...</code>“。cmpxchg是CAS的汇编指令。在CPU架构中依靠lock信号保证可见性并禁止重排序。</p><p>lock前缀是一个特殊的信号，执行过程如下：</p><ul><li>对总线和缓存上锁。</li><li>强制所有lock信号之前的指令，都在此之前被执行，并同步相关缓存。</li><li>执行lock后的指令（如cmpxchg）。</li><li>释放对总线和缓存上的锁。</li><li>强制所有lock信号之后的指令，都在此之后被执行，并同步相关缓存。</li></ul><p>因此，lock信号虽然不是内存屏障，但具有mfence的语义（当然，还有<code>排他性</code>的语义）。</p><p>与内存屏障相比，lock信号要额外对总线和缓存上锁，成本更高。</p><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span><a href="#%E9%94%81" title="锁"></a>锁</span></a></h2><p>JVM的内置锁通过操作系统的管程实现。且不论管程的实现原理，由于管程是一种互斥资源，修改互斥资源至少需要一个CAS操作。因此，锁必然也使用了lock信号，具有mfence的语义。</p><p>锁的mfence语义实现了Happens-Before关系中的监视器锁规则。</p><blockquote><p>CAS具有同样的mfence语义，也必然具有与锁相同的偏序关系。尽管JVM没有对此作出显式的要求。</p></blockquote><hr><blockquote><p>参考:<br><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/" target="_blank" rel="noopener noreferrer">从Java视角理解系统结构(一)CPU上下文切换</a></p><ul><li><a href="http://ifeve.com/java-context-switch/" target="_blank" rel="noopener noreferrer">从Java视角理解系统结构(一)CPU上下文切换</a></li><li><a href="http://ifeve.com/from-javaeye-cpu-cache/" target="_blank" rel="noopener noreferrer">从Java视角理解系统结构（二）CPU缓存</a></li><li><a href="http://ifeve.com/from-javaeye-false-sharing/" target="_blank" rel="noopener noreferrer">从Java视角理解系统结构（三）伪共享</a></li><li><a href="https://www.jianshu.com/p/506c1e38a922" target="_blank" rel="noopener noreferrer">面试必问的volatile，你了解多少？</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener noreferrer">乱序执行</a></li><li><a href="http://blog.csdn.net/gjq_1988/article/details/39520729" target="_blank" rel="noopener noreferrer">（转）CPU乱序执行原理</a></li><li><a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener noreferrer">Java内存访问重排序的研究</a></li><li><a href="http://blog.csdn.net/dd864140130/article/details/56494925" target="_blank" rel="noopener noreferrer">谈乱序执行和内存屏障</a></li><li><a href="http://ifeve.com/memory-barriers-or-fences/" target="_blank" rel="noopener noreferrer">内存屏障</a>（阅读本文的原文需要翻墙，这里给出一篇译文的地址）</li><li><a href="http://0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/" target="_blank" rel="noopener noreferrer">聊聊原子变量、锁、内存屏障那点事</a></li><li><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/%E8%81%8A%E8%81%8A%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%94%EF%BC%89Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" target="_blank" rel="noopener noreferrer">聊聊高并发（三十五）Java内存模型那些事（三）理解内存屏障</a></li></ul></blockquote>`,142),h=[r];function p(k,o){return a(),s("div",null,h)}const E=i(t,[["render",p],["__file","memorybarrier.html.vue"]]),B=JSON.parse('{"path":"/java/concurrency/memorybarrier.html","title":"内存屏障","lang":"zh-CN","frontmatter":{"title":"内存屏障","author":"Evan","editLink":false,"comment":false,"tag":["Java"],"date":"2025-03-24T00:00:00.000Z","description":"内存屏障是硬件之上、操作系统或JVM之下，对并发作出的最后一层支持。再向下是是硬件提供的支持；向上是操作系统或JVM对内存屏障作出的各种封装。内存屏障是一种标准，各厂商可能采用不同的实现。 本文仅为了帮助理解JVM提供的并发机制。首先，从volatile的语义引出可见性与重排序问题；接下来，阐述问题的产生原理，了解为什么需要内存屏障；然后，浅谈内存屏障...","head":[["meta",{"property":"og:url","content":"https://leslie-dd.github.io/leslie-blog/leslie-blog/java/concurrency/memorybarrier.html"}],["meta",{"property":"og:site_name","content":"Leslie的博客"}],["meta",{"property":"og:title","content":"内存屏障"}],["meta",{"property":"og:description","content":"内存屏障是硬件之上、操作系统或JVM之下，对并发作出的最后一层支持。再向下是是硬件提供的支持；向上是操作系统或JVM对内存屏障作出的各种封装。内存屏障是一种标准，各厂商可能采用不同的实现。 本文仅为了帮助理解JVM提供的并发机制。首先，从volatile的语义引出可见性与重排序问题；接下来，阐述问题的产生原理，了解为什么需要内存屏障；然后，浅谈内存屏障..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-23T18:19:35.000Z"}],["meta",{"property":"article:author","content":"Evan"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2025-03-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-23T18:19:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存屏障\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-23T18:19:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Evan\\"}]}"]]},"headers":[{"level":2,"title":"volatile变量规则","slug":"volatile变量规则","link":"#volatile变量规则","children":[]},{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"正确姿势","slug":"正确姿势","link":"#正确姿势","children":[]},{"level":2,"title":"可见性与重排序","slug":"可见性与重排序","link":"#可见性与重排序","children":[]},{"level":2,"title":"可见性","slug":"可见性","link":"#可见性","children":[{"level":3,"title":"定义","slug":"定义-1","link":"#定义-1","children":[]},{"level":3,"title":"问题来源","slug":"问题来源","link":"#问题来源","children":[]}]},{"level":2,"title":"重排序","slug":"重排序","link":"#重排序","children":[{"level":3,"title":"定义","slug":"定义-2","link":"#定义-2","children":[]},{"level":3,"title":"问题来源","slug":"问题来源-1","link":"#问题来源-1","children":[]}]},{"level":2,"title":"内存屏障","slug":"内存屏障","link":"#内存屏障","children":[]},{"level":2,"title":"标准","slug":"标准","link":"#标准","children":[]},{"level":2,"title":"x86架构的内存屏障","slug":"x86架构的内存屏障","link":"#x86架构的内存屏障","children":[{"level":3,"title":"Store Barrier","slug":"store-barrier","link":"#store-barrier","children":[]},{"level":3,"title":"Load Barrier","slug":"load-barrier","link":"#load-barrier","children":[]},{"level":3,"title":"Full Barrier","slug":"full-barrier","link":"#full-barrier","children":[]}]},{"level":2,"title":"volatile如何解决内存可见性与处理器重排序问题","slug":"volatile如何解决内存可见性与处理器重排序问题","link":"#volatile如何解决内存可见性与处理器重排序问题","children":[]},{"level":2,"title":"JVM对内存屏障作出的其他封装","slug":"jvm对内存屏障作出的其他封装","link":"#jvm对内存屏障作出的其他封装","children":[]},{"level":2,"title":"final关键字","slug":"final关键字","link":"#final关键字","children":[{"level":3,"title":"再谈部分初始化","slug":"再谈部分初始化","link":"#再谈部分初始化","children":[]}]},{"level":2,"title":"CAS","slug":"cas","link":"#cas","children":[]},{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[]}],"git":{"createdTime":1742753975000,"updatedTime":1742753975000,"contributors":[{"name":"Leslie","email":"LeslieDYF@gmail.com","commits":1}]},"readingTime":{"minutes":27.65,"words":8295},"filePathRelative":"java/concurrency/memorybarrier.md","localizedDate":"2025年3月24日","excerpt":"<p>内存屏障是硬件之上、操作系统或JVM之下，对并发作出的最后一层支持。再向下是是硬件提供的支持；向上是操作系统或JVM对内存屏障作出的各种封装。内存屏障是一种标准，各厂商可能采用不同的实现。</p>\\n<p>本文仅为了帮助理解JVM提供的并发机制。首先，从volatile的语义引出可见性与重排序问题；接下来，阐述问题的产生原理，了解为什么需要内存屏障；然后，浅谈内存屏障的标准、厂商对内存屏障的支持，并以volatile为例讨论内存屏障如何解决这些问题；最后，补充介绍JVM在内存屏障之上作出的几个封装。为了帮助理解，会简要讨论硬件架构层面的一些基本原理（特别是CPU架构），但不会深入实现机制。</p>","autoDesc":true}');export{E as comp,B as data};
