import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as m,c as i,a as s,b as a,d as l,e as r}from"./app-BMIN2c_3.js";const c={},o=s("h2",{id:"定义",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#定义"},[s("span",null,"定义")])],-1),p={href:"https://en.wikipedia.org/wiki/Merge_sort",target:"_blank",rel:"noopener noreferrer"},h=s("h2",{id:"性质",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#性质"},[s("span",null,"性质")])],-1),g=s("p",null,[a("归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[a("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a("，空间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a("。")],-1),d=s("p",null,[a("归并排序可以只使用 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),a(" 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。")],-1),u=r(`<h2 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h2><h3 id="合并" tabindex="-1"><a class="header-anchor" href="#合并"><span>合并</span></a></h3><p>归并排序最核心的部分是合并（merge）过程：将两个有序的数组 <code>a[i]</code> 和 <code>b[j]</code> 合并为一个有序数组 <code>c[k]</code>。</p><p>从左往右枚举 <code>a[i]</code> 和 <code>b[j]</code>，找出最小的值并放入数组 <code>c[k]</code>；重复上述过程直到 <code>a[i]</code> 和 <code>b[j]</code> 有一个为空时，将另一个数组剩下的元素放入 <code>c[k]</code>。</p><p>为保证排序的稳定性，前段首元素小于或等于后段首元素时（<code>a[i] &lt;= b[j]</code>）而非小于时（<code>a[i] &lt; b[j]</code>）就要作为最小值放入 <code>c[k]</code>。</p><h4 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h4><p>=== &quot;C/C++&quot;<br> === &quot;数组实现&quot;<br><code>cpp void merge(const int *a, size_t aLen, const int *b, size_t bLen, int *c) { size_t i = 0, j = 0, k = 0; while (i &lt; aLen &amp;&amp; j &lt; bLen) { if (b[j] &lt; a[i]) { // &lt;!&gt; 先判断 b[j] &lt; a[i]，保证稳定性 c[k] = b[j]; ++j; } else { c[k] = a[i]; ++i; } ++k; } // 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中 for (; i &lt; aLen; ++i, ++k) c[k] = a[i]; for (; j &lt; bLen; ++j, ++k) c[k] = b[j]; } </code></p><pre><code>=== &quot;指针实现&quot;
    \`\`\`cpp
    void merge(const int *aBegin, const int *aEnd, const int *bBegin,
               const int *bEnd, int *c) {
      while (aBegin != aEnd &amp;&amp; bBegin != bEnd) {
        if (*bBegin &lt; *aBegin) {
          *c = *bBegin;
          ++bBegin;
        } else {
          *c = *aBegin;
          ++aBegin;
        }
        ++c;
      }
      for (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;
      for (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;
    }
    \`\`\`

也可使用 \`&lt;algorithm&gt;\` 库的 \`merge\` 函数，用法与上述指针式写法的相同。
</code></pre><p>=== &quot;Python&quot;<br><code>python def merge(a, b): i, j = 0, 0 c = [] while(i &lt; len(a) and j &lt; len(b)): # &lt;!&gt; 先判断 b[j] &lt; a[i]，保证稳定性 if(b[j] &lt; a[i]): c.append(b[j]) j += 1 else: c.append(a[i]) i += 1 # 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中 c.extend(a[i:]) c.extend(b[j:]) return c </code></p><h3 id="分治法实现归并排序" tabindex="-1"><a class="header-anchor" href="#分治法实现归并排序"><span>分治法实现归并排序</span></a></h3>`,10),x=s("ol",null,[s("li",null,[s("p",null,[a("当数组长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 时，该数组就已经是有序的，不用再分解。")])]),s("li",null,[s("p",null,[a("当数组长度大于 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 时，该数组很可能不是有序的。此时将该数组分为两段，再分别检查两个数组是否有序（用第 1 条）。如果有序，则将它们合并为一个有序数组；否则对不有序的数组重复第 2 条，再合并。")])])],-1),w=s("p",null,"用数学归纳法可以证明该流程可以将一个数组转变为有序数组。",-1),y=s("p",null,[a("为保证排序的复杂度，通常将数组分为尽量等长的两段（"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"d"),s("mo",null,"="),s("mrow",null,[s("mo",{fence:"true"},"⌊"),s("mstyle",{displaystyle:"true",scriptlevel:"0"},[s("mfrac",null,[s("mrow",null,[s("mi",null,"l"),s("mo",null,"+"),s("mi",null,"r")]),s("mn",null,"2")])]),s("mo",{fence:"true"},"⌋")])]),s("annotation",{encoding:"application/x-tex"},"mid = \\left\\lfloor \\dfrac{l + r}{2} \\right\\rfloor")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"2.4em","vertical-align":"-0.95em"}}),s("span",{class:"minner"},[s("span",{class:"mopen delimcenter",style:{top:"0em"}},[s("span",{class:"delimsizing size3"},"⌊")]),s("span",{class:"mord"},[s("span",{class:"mopen nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"1.3714em"}},[s("span",{style:{top:"-2.314em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2")])]),s("span",{style:{top:"-3.23em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"frac-line",style:{"border-bottom-width":"0.04em"}})]),s("span",{style:{top:"-3.677em"}},[s("span",{class:"pstrut",style:{height:"3em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.686em"}},[s("span")])])])]),s("span",{class:"mclose nulldelimiter"})]),s("span",{class:"mclose delimcenter",style:{top:"0em"}},[s("span",{class:"delimsizing size3"},"⌋")])])])])]),a("）。")],-1),k=s("h4",{id:"实现-1",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#实现-1"},[s("span",null,"实现")])],-1),_=s("p",null,[a("注意下面的代码所表示的区间分别是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"l"),s("mo",{separator:"true"},","),s("mi",null,"r"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[l, r)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),s("span",{class:"mclose"},")")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"l"),s("mo",{separator:"true"},","),s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"d"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[l, mid)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mclose"},")")])])]),a("，"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"m"),s("mi",null,"i"),s("mi",null,"d"),s("mo",{separator:"true"},","),s("mi",null,"r"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[mid, r)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"mi"),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),s("span",{class:"mclose"},")")])])]),a("。")],-1),b=s("p",null,[a('=== "C/C++"'),s("br"),s("code",null,"cpp void merge_sort(int *a, int l, int r) { if (r - l <= 1) return; // 分解 int mid = l + ((r - l) >> 1); merge_sort(a, l, mid), merge_sort(a, mid, r); // 合并 int tmp[1024] = {}; // 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用 // vector；先将合并的结果放在 tmp 里，再返回到数组 a merge(a + l, a + mid, a + mid, a + r, tmp + l); // pointer-style merge for (int i = l; i < r; ++i) a[i] = tmp[i]; } ")],-1),f=s("p",null,[a('=== "Python"'),s("br"),s("code",null,"python def merge_sort(a, ll, rr): if rr - ll <= 1: return # 分解 mid = (rr + ll) // 2 merge_sort(a, ll, mid) merge_sort(a, mid, rr) # 合并 a[ll:rr] = merge(a[ll:mid], a[mid:rr]) ")],-1),M=s("h3",{id:"倍增法实现归并排序",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#倍增法实现归并排序"},[s("span",null,"倍增法实现归并排序")])],-1),v=s("p",null,[a("已知当数组长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 时，该数组就已经是有序的。")],-1),L=s("p",null,[a("将数组全部切成长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 的段。")],-1),j=s("p",null,[a("从左往右依次合并两个长度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"},"1")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])]),a(" 的有序段，得到一系列长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"\\le 2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),a(" 的有序段；")],-1),z=s("p",null,[a("从左往右依次合并两个长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"\\le 2")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"2")])])]),a(" 的有序段，得到一系列长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"4")]),s("annotation",{encoding:"application/x-tex"},"\\le 4")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"4")])])]),a(" 的有序段；")],-1),B=s("p",null,[a("从左往右依次合并两个长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"4")]),s("annotation",{encoding:"application/x-tex"},"\\le 4")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"4")])])]),a(" 的有序段，得到一系列长度 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mn",null,"8")]),s("annotation",{encoding:"application/x-tex"},"\\le 8")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"8")])])]),a(" 的有序段；")],-1),E=s("p",null,"……",-1),T=s("p",null,"重复上述过程直至数组只剩一个有序段，该段就是排好序的原数组。",-1),C=s("p",null,[a('???+ note " 为什么是 '),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"≤"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"\\le n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a(" 而不是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",null,"="),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"= n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.3669em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])]),a('"'),s("br"),a(" 数组的长度很可能不是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"x")])]),s("annotation",{encoding:"application/x-tex"},"2^x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6644em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6644em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"x")])])])])])])])])])]),a("，此时在最后就可能出现长度不完整的段，可能出现最后一个段是独立的情况。")],-1),q=s("h4",{id:"实现-2",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#实现-2"},[s("span",null,"实现")])],-1),N=s("p",null,[a('=== "C/C++"'),s("br"),s("code",null,"cpp void merge_sort(int *a, size_t n) { int tmp[1024] = {}; // 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用 // vector；先将合并的结果放在 tmp 里，再返回到数组 a for (size_t seg = 1; seg < n; seg <<= 1) { for (size_t left1 = 0; left1 < n - seg; left1 += seg + seg) { // n - seg: 如果最后只有一个段就不用合并 size_t right1 = left1 + seg; size_t left2 = right1; size_t right2 = std::min(left2 + seg, n); // <!> 注意最后一个段的边界 merge(a + left1, a + right1, a + left2, a + right2, tmp + left1); // pointer-style merge for (size_t i = left1; i < right2; ++i) a[i] = tmp[i]; } } } ")],-1),P=s("p",null,[a('=== "Python"'),s("br"),s("code",null,"python def merge_sort(a): seg = 1 while seg < len(a): for l1 in range(0, len(a) - seg, seg + seg): r1 = l1 + seg l2 = r1 r2 = l2 + seg a[l1:r2] = merge(a[l1:r1], a[l2:r2]) seg <<= 1 ")],-1),A=s("h2",{id:"逆序对",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#逆序对"},[s("span",null,"逆序对")])],-1),D=s("p",null,[a("逆序对是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"i"),s("mo",null,"<"),s("mi",null,"j")]),s("annotation",{encoding:"application/x-tex"},"i < j")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6986em","vertical-align":"-0.0391em"}}),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"<"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.854em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05724em"}},"j")])])]),a(" 且 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"a"),s("mi",null,"i")]),s("mo",null,">"),s("msub",null,[s("mi",null,"a"),s("mi",null,"j")])]),s("annotation",{encoding:"application/x-tex"},"a_i > a_j")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6891em","vertical-align":"-0.15em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"a"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"i")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7167em","vertical-align":"-0.2861em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"a"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3117em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.05724em"}},"j")])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.2861em"}},[s("span")])])])])])])])]),a(" 的有序数对 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"("),s("mi",null,"i"),s("mo",{separator:"true"},","),s("mi",null,"j"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"(i, j)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05724em"}},"j"),s("span",{class:"mclose"},")")])])]),a("。")],-1),F=s("p",null,[a("排序后的数组无逆序对，归并排序的合并操作中，每次后段首元素被作为当前最小值取出时，前段剩余元素个数之和即是合并操作减少的逆序对数量；故归并排序计算逆序对数量的额外时间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[a("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a("，对于 C/C++ 代码将 "),s("code",null,"merge"),a(" 过程的 "),s("code",null,"if(b[j] < a[i])"),a(" 部分加上 "),s("code",null,"cnt += aLen - i"),a(" 或 "),s("code",null,"cnt += aEnd - aBegin"),a(" 即可，对于 Python 代码将 "),s("code",null,"merge"),a(" 过程的 "),s("code",null,"if(b[j] < a[i]):"),a(" 部分加上 "),s("code",null,"cnt += len(a) - i"),a(" 即可。")],-1),O=s("p",null,[a("此外，逆序对计数即是将元素依次加入数组时统计当前大于其的元素数量，将数组离散化后即是区间求和问题，使用树状数组或线段树解决的时间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[a("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a(" 且空间复杂度为 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"Θ"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Theta (n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"Θ"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a("。")],-1),S=s("h2",{id:"外部链接",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#外部链接"},[s("span",null,"外部链接")])],-1),V={href:"https://www.geeksforgeeks.org/merge-sort/",target:"_blank",rel:"noopener noreferrer"},Z={href:"https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"},G={href:"https://zh.wikipedia.org/wiki/%E9%80%86%E5%BA%8F%E5%AF%B9",target:"_blank",rel:"noopener noreferrer"};function I(J,R){const t=e("ExternalLinkIcon");return m(),i("div",null,[o,s("p",null,[a("归并排序（"),s("a",p,[a("merge sort"),l(t)]),a("）是高效的基于比较的稳定排序算法。")]),h,g,d,u,x,w,y,k,_,b,f,M,v,L,j,z,B,E,T,C,q,N,P,A,D,F,O,S,s("ul",null,[s("li",null,[s("a",V,[a("Merge Sort - GeeksforGeeks"),l(t)])]),s("li",null,[s("a",Z,[a("归并排序 - 维基百科，自由的百科全书"),l(t)])]),s("li",null,[s("a",G,[a("逆序对 - 维基百科，自由的百科全书"),l(t)])])])])}const K=n(c,[["render",I],["__file","merge-sort.html.vue"]]),Q=JSON.parse('{"path":"/algorithms/sort/merge-sort.html","title":"","lang":"zh-CN","frontmatter":{"description":"定义 归并排序（merge sort）是高效的基于比较的稳定排序算法。 性质 归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 Θ(nlogn)，空间复杂度为 Θ(n)。 归并排序可以只使用 Θ(1) 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。 过程 合并 归并排序最核心的部分是合并（merge）过程：将两个有...","head":[["meta",{"property":"og:url","content":"https://leslie-dd.github.io/leslie-blog/leslie-blog/algorithms/sort/merge-sort.html"}],["meta",{"property":"og:site_name","content":"Leslie的博客"}],["meta",{"property":"og:description","content":"定义 归并排序（merge sort）是高效的基于比较的稳定排序算法。 性质 归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 Θ(nlogn)，空间复杂度为 Θ(n)。 归并排序可以只使用 Θ(1) 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。 过程 合并 归并排序最核心的部分是合并（merge）过程：将两个有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-19T07:24:37.000Z"}],["meta",{"property":"article:author","content":"Leslie"}],["meta",{"property":"article:modified_time","content":"2024-04-19T07:24:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-19T07:24:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Leslie\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"性质","slug":"性质","link":"#性质","children":[]},{"level":2,"title":"过程","slug":"过程","link":"#过程","children":[{"level":3,"title":"合并","slug":"合并","link":"#合并","children":[]},{"level":3,"title":"分治法实现归并排序","slug":"分治法实现归并排序","link":"#分治法实现归并排序","children":[]},{"level":3,"title":"倍增法实现归并排序","slug":"倍增法实现归并排序","link":"#倍增法实现归并排序","children":[]}]},{"level":2,"title":"逆序对","slug":"逆序对","link":"#逆序对","children":[]},{"level":2,"title":"外部链接","slug":"外部链接","link":"#外部链接","children":[]}],"git":{"createdTime":1713511477000,"updatedTime":1713511477000,"contributors":[{"name":"Leslie","email":"LeslieDYF@gmail.com","commits":1}]},"readingTime":{"minutes":5.24,"words":1571},"filePathRelative":"algorithms/sort/merge-sort.md","localizedDate":"2024年4月19日","excerpt":"<h2>定义</h2>\\n<p>归并排序（<a href=\\"https://en.wikipedia.org/wiki/Merge_sort\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">merge sort</a>）是高效的基于比较的稳定排序算法。</p>\\n<h2>性质</h2>\\n<p>归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi mathvariant=\\"normal\\">Θ</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">\\\\Theta (n \\\\log n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">Θ</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mop\\">lo<span style=\\"margin-right:0.01389em;\\">g</span></span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>，空间复杂度为 <span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi mathvariant=\\"normal\\">Θ</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">\\\\Theta (n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">Θ</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>。</p>","autoDesc":true}');export{K as comp,Q as data};
