import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as p,c as o,a,b as n,d as t,w as c,e as s}from"./app-BMIN2c_3.js";const h={},d=a("p",null,"本页面将简要介绍堆排序。",-1),m=a("h2",{id:"定义",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#定义"},[a("span",null,"定义")])],-1),u=a("h2",{id:"过程",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#过程"},[a("span",null,"过程")])],-1),b=a("p",null,"堆排序的本质是建立在堆上的选择排序。",-1),g=a("h3",{id:"排序",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#排序"},[a("span",null,"排序")])],-1),k=a("p",null,"首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质；",-1),_=a("p",null,"之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆的性质；",-1),f=a("p",null,[n("以此类推，在第 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n"),a("mo",null,"−"),a("mn",null,"1")]),a("annotation",{encoding:"application/x-tex"},"n-1")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),a("span",{class:"mbin"},"−"),a("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6444em"}}),a("span",{class:"mord"},"1")])])]),n(" 次操作后，整个数组就完成了排序。")],-1),x=s(`<h3 id="在数组上建立二叉堆" tabindex="-1"><a class="header-anchor" href="#在数组上建立二叉堆"><span>在数组上建立二叉堆</span></a></h3><p>从根节点开始，依次将每一层的节点排列在数组里。</p><p>于是有数组中下标为 <code>i</code> 的节点，对应的父结点、左子结点和右子结点如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token function">iParent</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">iLeftChild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">iRightChild</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="性质" tabindex="-1"><a class="header-anchor" href="#性质"><span>性质</span></a></h2><h3 id="稳定性" tabindex="-1"><a class="header-anchor" href="#稳定性"><span>稳定性</span></a></h3><p>同选择排序一样，由于其中交换位置的操作，所以是不稳定的排序算法。</p><h3 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度"><span>时间复杂度</span></a></h3>`,8),w=a("p",null,[n("堆排序的最优时间复杂度、平均时间复杂度、最坏时间复杂度均为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mi",null,"log"),a("mo",null,"⁡"),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n\\log n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),a("span",{class:"mop"},[n("lo"),a("span",{style:{"margin-right":"0.01389em"}},"g")]),a("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),n("。")],-1),y=s(`<h3 id="空间复杂度" tabindex="-1"><a class="header-anchor" href="#空间复杂度"><span>空间复杂度</span></a></h3><p>由于可以在输入数组上建立堆，所以这是一个原地算法。</p><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><p>=== &quot;C++&quot;<br> \`\`\`cpp<br> void sift_down(int arr[], int start, int end) {<br> // 计算父结点和子结点的下标<br> int parent = start;<br> int child = parent * 2 + 1;<br> while (child &lt;= end) { // 子结点下标在范围内才做比较<br> // 先比较两个子结点大小，选择最大的<br> if (child + 1 &lt;= end &amp;&amp; arr[child] &lt; arr[child + 1]) child++;<br> // 如果父结点比子结点大，代表调整完毕，直接跳出函数<br> if (arr[parent] &gt;= arr[child])<br> return;<br> else { // 否则交换父子内容，子结点再和孙结点比较<br> swap(arr[parent], arr[child]);<br> parent = child;<br> child = parent * 2 + 1;<br> }<br> }<br> }</p><pre><code>void heap_sort(int arr[], int len) {
  // 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)
  for (int i = (len - 1 - 1) / 2; i &gt;= 0; i--) sift_down(arr, i, len - 1);
  // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕
  for (int i = len - 1; i &gt; 0; i--) {
    swap(arr[0], arr[i]);
    sift_down(arr, 0, i - 1);
  }
}
\`\`\`
</code></pre><p>=== &quot;Python&quot;<br> \`\`\`python<br> def sift_down(arr, start, end):<br> # 计算父结点和子结点的下标<br> parent = int(start)<br> child = int(parent * 2 + 1)<br> while child &lt;= end: # 子结点下标在范围内才做比较<br> # 先比较两个子结点大小，选择最大的<br> if child + 1 &lt;= end and arr[child] &lt; arr[child + 1]:<br> child += 1<br> # 如果父结点比子结点大，代表调整完毕，直接跳出函数<br> if arr[parent] &gt;= arr[child]:<br> return<br> else: # 否则交换父子内容，子结点再和孙结点比较<br> arr[parent], arr[child] = arr[child], arr[parent]<br> parent = child<br> child = int(parent * 2 + 1)</p><pre><code>def heap_sort(arr, len):
  # 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)
    i = (len - 1 - 1) / 2
    while(i &gt;= 0):
        sift_down(arr, i, len - 1)
        i -= 1
  # 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕
    i = len - 1
    while(i &gt; 0):
        arr[0], arr[i] = arr[i], arr[0]
        sift_down(arr, 0, i - 1)
        i -= 1
\`\`\`
</code></pre><h2 id="外部链接" tabindex="-1"><a class="header-anchor" href="#外部链接"><span>外部链接</span></a></h2>`,8),v={href:"https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"};function L(C,E){const l=e("RouteLink"),r=e("ExternalLinkIcon");return p(),o("div",null,[d,m,a("p",null,[n("堆排序（英语：Heapsort）是指利用 "),t(l,{to:"/algorithms/ds/binary-heap.html"},{default:c(()=>[n("二叉堆")]),_:1}),n(" 这种数据结构所设计的一种排序算法。堆排序的适用数据结构为数组。")]),u,b,g,k,_,f,x,w,y,a("ul",null,[a("li",null,[a("a",v,[n("堆排序 - 维基百科，自由的百科全书"),t(r)])])])])}const T=i(h,[["render",L],["__file","heap-sort.html.vue"]]),q=JSON.parse('{"path":"/algorithms/sort/heap-sort.html","title":"","lang":"zh-CN","frontmatter":{"description":"本页面将简要介绍堆排序。 定义 堆排序（英语：Heapsort）是指利用 这种数据结构所设计的一种排序算法。堆排序的适用数据结构为数组。 过程 堆排序的本质是建立在堆上的选择排序。 排序 首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质； 之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆...","head":[["meta",{"property":"og:url","content":"https://leslie-dd.github.io/leslie-blog/leslie-blog/algorithms/sort/heap-sort.html"}],["meta",{"property":"og:site_name","content":"Leslie的博客"}],["meta",{"property":"og:description","content":"本页面将简要介绍堆排序。 定义 堆排序（英语：Heapsort）是指利用 这种数据结构所设计的一种排序算法。堆排序的适用数据结构为数组。 过程 堆排序的本质是建立在堆上的选择排序。 排序 首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质； 之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-19T07:24:37.000Z"}],["meta",{"property":"article:author","content":"Leslie"}],["meta",{"property":"article:modified_time","content":"2024-04-19T07:24:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-19T07:24:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Leslie\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":2,"title":"过程","slug":"过程","link":"#过程","children":[{"level":3,"title":"排序","slug":"排序","link":"#排序","children":[]},{"level":3,"title":"在数组上建立二叉堆","slug":"在数组上建立二叉堆","link":"#在数组上建立二叉堆","children":[]}]},{"level":2,"title":"性质","slug":"性质","link":"#性质","children":[{"level":3,"title":"稳定性","slug":"稳定性","link":"#稳定性","children":[]},{"level":3,"title":"时间复杂度","slug":"时间复杂度","link":"#时间复杂度","children":[]},{"level":3,"title":"空间复杂度","slug":"空间复杂度","link":"#空间复杂度","children":[]}]},{"level":2,"title":"实现","slug":"实现","link":"#实现","children":[]},{"level":2,"title":"外部链接","slug":"外部链接","link":"#外部链接","children":[]}],"git":{"createdTime":1713511477000,"updatedTime":1713511477000,"contributors":[{"name":"Leslie","email":"LeslieDYF@gmail.com","commits":1}]},"readingTime":{"minutes":2.87,"words":860},"filePathRelative":"algorithms/sort/heap-sort.md","localizedDate":"2024年4月19日","excerpt":"<p>本页面将简要介绍堆排序。</p>\\n<h2>定义</h2>\\n<p>堆排序（英语：Heapsort）是指利用 <a href=\\"/leslie-blog/algorithms/ds/binary-heap.html\\" target=\\"_blank\\">二叉堆</a> 这种数据结构所设计的一种排序算法。堆排序的适用数据结构为数组。</p>\\n<h2>过程</h2>\\n<p>堆排序的本质是建立在堆上的选择排序。</p>\\n<h3>排序</h3>\\n<p>首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质；</p>\\n<p>之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆的性质；</p>","autoDesc":true}');export{T as comp,q as data};
